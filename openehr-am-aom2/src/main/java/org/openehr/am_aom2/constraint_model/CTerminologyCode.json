{
    "attributes": [
        {
            "description": "Constraint status of this terminology constraint. If Void, the meaning is as follows:",
            "multiplicity": "0..1",
            "name": "constraint_status",
            "type": "CONSTRAINT_STATUS"
        },
        {
            "description": "Type of individual constraint - a single string that can either be a local at-code, or a local ac-code signifying a locally defined value set. If an ac-code, assumed_value may contain an at-code from the value set of the ac-code.",
            "multiplicity": "0..1",
            "name": "constraint",
            "type": "String"
        },
        {
            "description": "Assumed Terminology code value.",
            "multiplicity": "0..1",
            "name": "assumed_value",
            "type": "Terminology_code"
        },
        {
            "description": "",
            "multiplicity": "0..1",
            "name": "default_value",
            "type": "Terminology_code"
        }
    ],
    "constants": [],
    "functions": [
        {
            "meaning": "True if `_constraint_status_` is defined and equals `required` OR if Void. I.e. in archetypes where `C_TERMINOLOGY_CODE` instances have no `_constraint_status_`, the `required` status is assumed, which applies to all legacy archetypes.",
            "name": "constraint_required",
            "parameters": [],
            "return_type": "Boolean"
        },
        {
            "meaning": "Return the effective integer value of the `_constraint_status_` field if it exists. If it is null, return 0, i.e. `required`.",
            "name": "effective_constraint_status",
            "parameters": [],
            "return_type": "Integer"
        },
        {
            "meaning": "Effective set of at-code values corresponding to an ac-code for a locally defined value set. Not defined for ac-codes that have no local value set.",
            "name": "value_set_expanded",
            "parameters": [],
            "return_type": "List"
        },
        {
            "meaning": "For locally defined value sets within individual code bindings: return the term URI(s) substituted from bindings for local at-codes in `_value_set_expanded_`.",
            "name": "value_set_substituted",
            "parameters": [],
            "return_type": "List"
        },
        {
            "meaning": "For locally defined value sets within individual code bindings: final set of external codes to which value set is resolved.",
            "name": "value_set_resolved",
            "parameters": [],
            "return_type": "List"
        },
        {
            "meaning": "True if a `_value_` is valid with respect to constraint expressed in concrete instance of this type.",
            "name": "valid_value",
            "parameters": [
                {
                    "name": "a_value",
                    "type": "Object"
                }
            ],
            "return_type": "Boolean"
        },
        {
            "meaning": "A generated prototype value from this constraint object.",
            "name": "prototype_value",
            "parameters": [],
            "return_type": "Terminology_code"
        },
        {
            "meaning": "True if `_constraint_` is empty.",
            "name": "any_allowed",
            "parameters": [],
            "return_type": "Boolean"
        },
        {
            "meaning": "True if `_other.any_allowed_` or else every constraint in the `_constraint_` list exists in the `_other.constraint_`, and `_effective_constraint_status()_` is \\<= `_other.effective_constraint_status()_`.",
            "name": "c_value_conforms_to",
            "parameters": [
                {
                    "name": "other",
                    "type": "Object"
                }
            ],
            "return_type": "Boolean"
        },
        {
            "meaning": "True if `_constraint_` and `_other.constraint_` are both value-set ids, and expand to identical value sets, or else are identical value codes; and `_effective_constraint_status()_` = `_other.effective_constraint_status()_`.",
            "name": "c_value_congruent_to",
            "parameters": [
                {
                    "name": "other",
                    "type": "Object"
                }
            ],
            "return_type": "Boolean"
        }
    ],
    "meta_info": {
        "base_types": [
            "C_PRIMITIVE_OBJECT"
        ],
        "classifier": "Class",
        "description": "Constrainer type for instances of `Terminology_code`. The constraint attribute can contain:",
        "name": "C_TERMINOLOGY_CODE"
    }
}